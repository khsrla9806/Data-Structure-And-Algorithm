# Ch06. 정렬

<br>

## 이진 탐색 (Binary Search)
- **오름차순 정렬이 되어 있는 리스트** 내에서 특정 값의 인덱스를 찾는 알고리즘을 말합니다.
- 리스트에서 중간에 위치한 값을 찾아서 찾고자하는 값이 왼쪽에 있는지 오른쪽에 있는지 판단하여 탐색 범위를 절반씩 줄여갑니다.
- O(logN)의 시간 복잡도를 갖습니다.
- 하지만 반드시 **정렬된 리스트에서만 사용**이 가능합니다.

<br>

## 정렬
- 정렬에는 안정 정렬과 불안정 정렬이 있습니다.
  1. 안정 정렬
     - 정렬 시에 중복된 값의 순서를 보장하는 정렬
  2. 불안정 정렬
     - 정렬 시에 중복된 값의 순서를 보장하지 않는 정렬
- 구현 방식에 따라서 In-place 정렬과 Out-of-place 정렬로 나눌 수 있습니다.
  1. In-place 정렬
     - 원본 데이터 내에서 정렬이 이루어지는 경우를 말합니다.
  2. Out-of-place 정렬
     - 원본 데이터가 아닌 새로운 배열로 정렬된 아웃풋 결과를 만드는 경우를 말합니다.

<br>

### Builder Sort
- 인접한 두 값을 비교하여 , 정렬되어 있지 않다면 위치를 교환합니다.
- 정렬이 완료된 요소를 제외하고 위의 과정을 반복합니다.
- O(N^2)의 시간 복잡도를 갖습니다.
- 직관적이고 단순한 알고리즘이지만, 속도가 많이 느리다는 특징이 있다.

<br>

### 삽입 정렬 (Insertion Sort)
- 리스트의 앞에서부터 이미 정렬된 서브 리스트의 값들과 비교합니다.
- 자신의 위치에 삽입합니다.
- 안정정렬이며, 단순한 알고리즘이라는 장점이 있습니다.
- 데이터의 이동이 많습니다.
- 평균 O(N^2)의 시간 복잡도를 갖습니다.
- 데이터가 모두 정렬되어 있는 경우에는 O(N)의 시간 복잡도를 갖습니다.

<br>

### 합병 정렬 (Merge Sort)
- 하나의 리스트를 **두 개의 균등한 크기의 리스트로 분할**하여 부분 리스트를 합치면서 정렬하여 전체가 정렬되도록 합치는 방법을 말합니다.
- 분할 정복 알고리즘을 사용합니다. (재귀함수를 사용)
- O(NlogN)의 시간 복잡도를 갖습니다.
  - 분할할 때 O(logN), 다시 합칠 때의 비교연산에서 O(N)이기 때문에 O(NlogN)의 시간 복잡도를 갖습니다.

<br>

### 퀵 정렬 (Quick Sort)
- 합병 정렬과 마찬가지로 둘씩 쪼개면서 정렬을 진행하기 때문에 O(NlogN)의 시간 복잡도를 갖습니다.
- 최악의 경우에 이미 정렬된 배열이라면 O(N^2)까지 늘어날 수도 있게 됩니다.
  - 최악의 Pivot값을 선택하는 경우를 피하기 위한 알고리즘도 존재합니다. => median of Three
- 추가적인 메모리 공간을 사용하지 않습니다.
- 불안정 정렬입니다.
- 합병 정렬에서 합병마다 생성해줬던 보조 배열의 경우 Ram에 생성이 되어, 사용할 때마다 CPU가 Ram에 접근해야 했습니다.
- 퀵 정렬의 경우 최초에 한번 메인 배열에 접근할 때만 Ram에 접근을 하고, 그 후로는 cache 메모리에 저장해두기 때문에 더 빠른 접근이 가능합니다.
- 정렬하는 방법
  - pivot 값을 정합니다.
  - pivot값을 기준으로 왼쪽은 작은 값, 오른쪽은 큰 값이 들어가게 됩니다.

